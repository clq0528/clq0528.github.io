<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>三菱PLC 3D互锁电路深度仿真</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* UI 面板 */
        #ui-overlay {
            position: absolute; top: 20px; left: 20px;
            width: 350px; background: rgba(0, 0, 0, 0.8);
            color: #fff; border: 1px solid #444; padding: 15px;
            border-radius: 8px; pointer-events: none;
        }

        /* 梯形图面板 */
        #ladder-panel {
            position: absolute; bottom: 20px; right: 20px;
            width: 450px; background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .rung { display: flex; align-items: center; height: 50px; border-bottom: 1px solid #ddd; position: relative; }
        .symbol { width: 60px; text-align: center; font-family: monospace; font-weight: bold; font-size: 14px; color: #333; }
        .active-logic { color: #2ecc71 !important; text-shadow: 0 0 5px #2ecc71; }
        .wire-3d-label { font-size: 10px; color: #aaa; }

        #btn-group {
            position: absolute; bottom: 40px; left: 20px;
            display: flex; gap: 15px; pointer-events: auto;
        }
        .ctrl-btn {
            padding: 12px 24px; border: none; border-radius: 5px; color: white;
            font-weight: bold; cursor: pointer; transition: 0.2s;
        }
        .btn-fwd { background: #27ae60; }
        .btn-rev { background: #2980b9; }
        .btn-stop { background: #c0392b; }
        .ctrl-btn:active { transform: scale(0.9); }

        #scan-indicator {
            position: absolute; left: 0; width: 100%; height: 2px;
            background: rgba(255, 165, 0, 0.7); display: none;
        }
    </style>
</head>
<body>

<div id="ui-overlay">
    <div style="font-size: 18px; color: #f1c40f; margin-bottom: 10px;">三菱 FX3U 互锁仿真控制台</div>
    <div id="status-log" style="font-size: 12px; line-height: 1.6; color: #ccc;">
        系统就绪。等待输入...<br>
        [互锁原理] Y0/Y1 线圈互相串联对方的常闭触点。
    </div>
</div>

<div id="btn-group">
    <button class="ctrl-btn btn-fwd" onmousedown="interact('x0')" onmouseup="release('x0')">正转 X0</button>
    <button class="ctrl-btn btn-rev" onmousedown="interact('x1')" onmouseup="release('x1')">反转 X1</button>
    <button class="ctrl-btn btn-stop" onmousedown="interact('x2')" onmouseup="release('x2')">停止 X2</button>
</div>

<!-- 梯形图逻辑显示 -->
<div id="ladder-panel">
    <div style="font-weight:bold; margin-bottom:10px; color:#555;">PLC 内部梯形图 (Ladder Logic)</div>
    <div id="scan-indicator"></div>
    <!-- Row 1 -->
    <div class="rung">
        <div class="symbol" id="l-x0">| |<br>X0</div>
        <div style="flex:1; height:2px; background:#333;" id="l-w1"></div>
        <div class="symbol" id="l-x2a">|/|<br>X2</div>
        <div style="flex:1; height:2px; background:#333;" id="l-w2"></div>
        <div class="symbol" id="l-y1nc" style="color:red; border:1px dashed red;">|/|<br>Y1互锁</div>
        <div style="flex:1; height:2px; background:#333;" id="l-w3"></div>
        <div class="symbol" id="l-y0">( )<br>Y0</div>
    </div>
    <!-- Row 2 -->
    <div class="rung">
        <div class="symbol" id="l-x1">| |<br>X1</div>
        <div style="flex:1; height:2px; background:#333;" id="l-w4"></div>
        <div class="symbol" id="l-x2b">|/|<br>X2</div>
        <div style="flex:1; height:2px; background:#333;" id="l-w5"></div>
        <div class="symbol" id="l-y0nc" style="color:red; border:1px dashed red;">|/|<br>Y0互锁</div>
        <div style="flex:1; height:2px; background:#333;" id="l-w6"></div>
        <div class="symbol" id="l-y1">( )<br>Y1</div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.152.0",
            "three/addons/": "https://esm.sh/three@0.152.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- PLC 核心逻辑状态 (保留原有逻辑) ---
    const plc = {
        in: { x0: 0, x1: 0, x2: 0 },
        mem: { y0: 0, y1: 0 },
        out: { y0: 0, y1: 0 },
        phase: 0
    };

    let scene, camera, renderer, controls, clock = new THREE.Clock();
    let wires = []; // 存储所有 3D 导线
    let contactors = {}; // 存储 KM1, KM2 模型
    let motorShaft;

    init();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(150, 150, 200);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        
        // 灯光
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(50, 100, 50);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // 地面
        const grid = new THREE.GridHelper(400, 40, 0x333333, 0x222222);
        scene.add(grid);

        createModels();
        createWires();
        
        window.addEventListener('resize', onWindowResize);
        
        // 启动扫描周期
        setInterval(scanCycle, 300); 
        animate();
    }

    /**
     * 创建 3D 模型组件
     */
    function createModels() {
        // 1. PLC 本体
        const plcGeo = new THREE.BoxGeometry(60, 40, 20);
        const plcMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
        const plcMesh = new THREE.Mesh(plcGeo, plcMat);
        plcMesh.position.set(-80, 20, 0);
        scene.add(plcMesh);
        addLabel(plcMesh, "MITSUBISHI FX3U", 0, 25, 0);

        // 2. 接触器 KM1 & KM2 (详细化)
        contactors.km1 = createContactor("KM1 (Forward)", 20, 20, 40);
        contactors.km2 = createContactor("KM2 (Reverse)", 20, 20, -40);

        // 3. 电机
        const motorGeo = new THREE.CylinderGeometry(15, 15, 40, 32);
        const motorMat = new THREE.MeshStandardMaterial({ color: 0x34495e });
        const motor = new THREE.Mesh(motorGeo, motorMat);
        motor.position.set(80, 15, 0);
        motor.rotation.z = Math.PI/2;
        scene.add(motor);
        
        const shaftGeo = new THREE.BoxGeometry(5, 30, 5);
        motorShaft = new THREE.Mesh(shaftGeo, new THREE.MeshStandardMaterial({color: 0xbdc3c7}));
        motorShaft.position.set(20, 0, 0); // 伸出电机的轴
        motor.add(motorShaft);
    }

    function createContactor(name, x, y, z) {
        const group = new THREE.Group();
        group.position.set(x, y, z);

        // 外壳
        const body = new THREE.Mesh(new THREE.BoxGeometry(30, 40, 30), new THREE.MeshStandardMaterial({color: 0x95a5a6}));
        group.add(body);

        // 可动衔铁 (Plunger)
        const plunger = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), new THREE.MeshStandardMaterial({color: 0xe67e22}));
        plunger.position.y = 15;
        group.add(plunger);

        // 触点示意（常闭 NC 区域）
        const ncBox = new THREE.Mesh(new THREE.BoxGeometry(8, 5, 20), new THREE.MeshStandardMaterial({color: 0x222222}));
        ncBox.position.set(0, 10, 15);
        group.add(ncBox);

        scene.add(group);
        addLabel(group, name, 0, 25, 0);
        
        return { group, plunger, ncBox };
    }

    /**
     * 创建垂直转折导线
     */
    function createWires() {
        // 定义接线路径 [起点, 中间点s, 终点]
        const paths = [
            { id: 'w_x0', color: 0x27ae60, points: [[-100,0,80], [-100,5,80], [-100,5,10], [-110,20,10]] }, // X0 按钮到 PLC
            { id: 'w_x1', color: 0x2980b9, points: [[-70,0,80], [-70,5,80], [-70,5,10], [-90,20,10]] }, // X1 按钮到 PLC
            { id: 'w_y0', color: 0xe74c3c, points: [[-60,20,0], [0,20,0], [0,20,40], [10,20,40]] },   // Y0 到 KM1
            { id: 'w_y1', color: 0xe74c3c, points: [[-60,10,0], [0,10,0], [0,10,-40], [10,10,-40]] }  // Y1 到 KM2
        ];

        paths.forEach(p => {
            const curve = new THREE.CatmullRomCurve3(p.points.map(pt => new THREE.Vector3(...pt)));
            // 注意：这里手动处理路径，避免曲线太圆滑，CatmullRom 在点少时接近直线
            const geometry = new THREE.TubeGeometry(curve, 64, 1, 8, false);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                emissive: 0x000000,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            wires.push({ id: p.id, mesh, material, color: p.color });
        });
    }

    // --- 交互控制 ---
    window.interact = function(id) {
        plc.in[id] = 1;
        updateWireVisual(id, true);
        addLog(`输入信号 ${id.toUpperCase()} 激活`);
    }

    window.release = function(id) {
        plc.in[id] = 0;
        updateWireVisual(id, false);
    }

    function updateWireVisual(id, active) {
        const wire = wires.find(w => w.id === 'w_' + id);
        if (wire) {
            wire.material.color.setHex(active ? wire.color : 0x444444);
            wire.material.emissive.setHex(active ? wire.color : 0x000000);
            wire.material.emissiveIntensity = active ? 2 : 0;
        }
    }

    /**
     * PLC 扫描周期仿真
     */
    function scanCycle() {
        const scanLine = document.getElementById('scan-indicator');
        
        // 1. 输入采样
        if (plc.phase === 0) {
            scanLine.style.display = 'none';
            plc.phase = 1;
        } 
        // 2. 程序执行 (第一行)
        else if (plc.phase === 1) {
            scanLine.style.display = 'block'; scanLine.style.top = '25px';
            
            // Y0 Logic = (X0 or Y0) and (not X2) and (not Y1)
            const stopPressed = plc.in.x2 === 1;
            const interlockY1 = !plc.mem.y1; // 物理常闭

            const resY0 = (plc.in.x0 || plc.mem.y0) && !stopPressed && interlockY1;
            plc.mem.y0 = resY0 ? 1 : 0;

            updateLadderRow(1, [plc.in.x0, !stopPressed, interlockY1, resY0]);
            plc.phase = 2;
        }
        // 3. 程序执行 (第二行)
        else if (plc.phase === 2) {
            scanLine.style.top = '75px';
            
            const stopPressed = plc.in.x2 === 1;
            const interlockY0 = !plc.mem.y0;

            const resY1 = (plc.in.x1 || plc.mem.y1) && !stopPressed && interlockY0;
            plc.mem.y1 = resY1 ? 1 : 0;

            updateLadderRow(2, [plc.in.x1, !stopPressed, interlockY0, resY1]);
            plc.phase = 3;
        }
        // 4. 输出刷新
        else if (plc.phase === 3) {
            plc.out.y0 = plc.mem.y0;
            plc.out.y1 = plc.mem.y1;
            
            // 同步 3D 效果
            update3DComponents();
            plc.phase = 0;
        }
    }

    function updateLadderRow(row, states) {
        if (row === 1) {
            setClass('l-x0', 'active-logic', states[0]);
            setClass('l-x2a', 'active-logic', states[1]);
            setClass('l-y1nc', 'active-logic', states[2]);
            setClass('l-y0', 'active-logic', states[3]);
        } else {
            setClass('l-x1', 'active-logic', states[0]);
            setClass('l-x2b', 'active-logic', states[1]);
            setClass('l-y0nc', 'active-logic', states[2]);
            setClass('l-y1', 'active-logic', states[3]);
        }
    }

    function update3DComponents() {
        // 更新导线发光
        updateWireVisual('y0', plc.out.y0);
        updateWireVisual('y1', plc.out.y1);

        // 接触器衔铁动作 (模拟吸合)
        contactors.km1.plunger.position.y = plc.out.y0 ? 5 : 15;
        contactors.km2.plunger.position.y = plc.out.y1 ? 5 : 15;
        
        // 接触器辅助触点颜色 (红色表示互锁断开)
        contactors.km1.ncBox.material.color.setHex(plc.out.y0 ? 0xff0000 : 0x222222);
        contactors.km2.ncBox.material.color.setHex(plc.out.y1 ? 0xff0000 : 0x222222);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // 电机旋转逻辑
        if (plc.out.y0) {
            motorShaft.rotation.y += 0.2;
        } else if (plc.out.y1) {
            motorShaft.rotation.y -= 0.2;
        }

        // 导线电流流动动画 (纹理偏移模拟)
        wires.forEach(w => {
            if (w.material.emissiveIntensity > 0) {
                // 如果需要更高级的效果，可以给 Tube 贴图并移动 offset
            }
        });

        controls.update();
        renderer.render(scene, camera);
    }

    // --- 辅助工具 ---
    function setClass(id, cls, active) {
        const el = document.getElementById(id);
        if(el) active ? el.classList.add(cls) : el.classList.remove(cls);
    }

    function addLabel(parent, text, x, y, z) {
        // 简单 3D 文本替代：使用 Console 打印或在 UI 显示，Three.js 文本较重
        // 此处简化处理
    }

    function addLog(msg) {
        const log = document.getElementById('status-log');
        log.innerHTML = msg + "<br>" + log.innerHTML.split('<br>').slice(0,5).join('<br>');
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>